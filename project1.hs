-- Name: Edward Soo, Annie Li
-- Student Number: 71680094, 

-- Returns the best next move
-- board: current state of the game, represented by an array of rows
-- me: 'w' or 'b'
-- moves: the number of moves to search ahead
oska_b0e7 board me moves = []

-- generate neighbor state, print state and eval value
print_moves_evals_b0e7:: [String] -> Char-> IO()
print_moves_evals_b0e7 state me =
  print_states_evals_b0e7 (gen_state_b0e7 state me) me  

print_states_evals_b0e7:: [[String]] -> Char -> IO()
print_states_evals_b0e7 [] me = putStrLn ""
print_states_evals_b0e7 (s:ss) me = do
  print_b_b0e7 s
  putStr "eval: "
  putStrLn (show (evaluate_state_b0e7 s me)) 
  putStrLn ""
  print_states_evals_b0e7 ss me 

-- displays a state
print_b_b0e7 state = disp_b_b0e7 state (length state)
disp_b_b0e7 [] n = putStr ""
disp_b_b0e7 (x:xs) n = do
  putStr [' ' | i <- [1..n - (length x)]]
  putStrLn (concat [c:' ':[] | c <- x])
  disp_b_b0e7 xs n 

-- Evaluates a state and returns an integer
evaluate_state_b0e7 state me =
  sum_rows_eval_b0e7 [] (head state) (tail state) me (length state)

-- Evaluates the state row by row
sum_rows_eval_b0e7:: [String] -> String -> [String] -> Char -> Int -> Int
sum_rows_eval_b0e7 pre this [] me h = eval_row_b0e7 pre this [] me h
sum_rows_eval_b0e7 pre this post me h =
  (eval_row_b0e7 pre this post me h) +
  (sum_rows_eval_b0e7 (this:pre) (head post) (tail post) me h)

-- Evaluates one row with regards to what is on its next and prev row
eval_row_b0e7::[String] -> String -> [String] -> Char -> Int -> Int
eval_row_b0e7 [] this post me h =
  (count_b0e7 this me) + (h * (count_block_move_b0e7 (head post) this (opponent_b0e7 me)))
eval_row_b0e7 pre this [] me h =
  (count_b0e7 this me)*h
eval_row_b0e7 pre this post me h
  | length pre == length post = (count_block_jumps_b0e7 (head pre) this (head post) me) * (h-length pre) + eval_occurence
  | length pre > length post = (count_block_jumps_b0e7 (pad_b0e7 (head pre)) this (head post) me) * (h-length pre) + eval_occurence
  | otherwise = (count_block_jumps_b0e7 (head pre) this (pad_b0e7 (head post)) me) * (h-length pre) + eval_occurence
  where eval_occurence = (count_b0e7 this me) * (length pre + 1)

-- Returns the number of jumps that is blocked
count_block_jumps_b0e7 _ [] _ _ = 0
count_block_jumps_b0e7 (bl:br:bs) (r:rs) (fl:fr:fs) me =
  (block_jump_b0e7 fl r br me) + (block_jump_b0e7 fr r bl me) +
  (count_block_jumps_b0e7 (br:bs) rs (fr:fs) me)

block_jump_b0e7 front this back me 
  | front == (opponent_b0e7 me) && this == me && back == me = 1
  | otherwise = 0

append_b0e7 [] e = [e]
append_b0e7 (x:xs) e = x:append_b0e7 xs e

pad_b0e7 list = '-':(append_b0e7 list '-')

-- returns the number of an element in a list
count_b0e7 [] e = 0
count_b0e7 (x:xs) e
  | x == e = 1 + count_b0e7 xs e
  | otherwise = count_b0e7 xs e

-- count the number of my pieces that are blocked by opponents
count_block_move_b0e7 this next me =
  count_surrounded_b0e7 [] (head interleaved) (tail interleaved) me (opponent_b0e7 me)
  where interleaved = interleave_b0e7 this next

-- count the number of x that are surrounded by y or end of lst
count_surrounded_b0e7 [] this right x y
  | head right == y && this == x = 1 + count_surrounded_b0e7 (this:[]) (head right) (tail right) x y
  | otherwise = count_surrounded_b0e7 (this:[]) (head right) (tail right) x y
count_surrounded_b0e7 left this [] x y
  | head left == y && this == x = 1
  | otherwise = 0
count_surrounded_b0e7 (l:ls) this (r:rs) x y
  | l == y && this == x && r == y = 1 + count_surrounded_b0e7 (this:l:ls) r rs x y
  | otherwise = count_surrounded_b0e7 (this:l:ls) r rs x y

interleave_b0e7 [] next = next
interleave_b0e7 this [] = this
interleave_b0e7 this next
  | length this > length next = head this:head next :interleave_b0e7 (tail this) (tail next)
  | otherwise = head next : head this : interleave_b0e7 (tail this) (tail next)


-- Use this function to generate all possible moves of current state
-- result does not include the current state; can be empty
gen_state_b0e7 board me
  | me == 'w' = gen_state_all_row_b0e7 [] board 'w'
  | otherwise = map reverse (gen_state_all_row_b0e7 [] (reverse board) 'b')

-- returns all possible states generated by making all legal moves of the board
gen_state_all_row_b0e7 pre [] me = []
gen_state_all_row_b0e7 pre post me =
  gen_state_row_b0e7 pre row (tail post) me ++
  gen_state_all_row_b0e7 (reverse(row:reverse pre)) (tail post) me
  where row = head post

-- returns all possible states generated by making all legal moves of a row
gen_state_row_b0e7 pre row post me
  -- last row
  | null post  = []
  -- second last row
  | length post == 1 = 
    gen_state_row_move_b0e7 pre row (head post) (tail post) me 0
  -- has more at least 2 rows below
  | otherwise = 
    gen_state_row_move_b0e7_jump_b0e7 pre row (head post) (head (tail post)) (tail (tail post)) me 0

-- returns all possible states generated by making all legal moves of a row when the row only has one other row below it
gen_state_row_move_b0e7 pre row nextRow post me j
  | j >= length row = []
  | length row > length nextRow =
    gen_state_upper_piece_move_left_b0e7 j pre row nextRow post me++
    gen_state_upper_piece_move_right_b0e7 j pre row nextRow post me++
    gen_state_row_move_b0e7 pre row nextRow post me (j+1)
  | otherwise =
    gen_state_lower_piece_move_left_b0e7 j pre row nextRow post me++
    gen_state_lower_piece_move_right_b0e7 j pre row nextRow post me++
    gen_state_row_move_b0e7 pre row nextRow post me (j+1)
  
-- returns all possible states generated by making all legal moves of a row when the row has at least two rows below it
gen_state_row_move_b0e7_jump_b0e7 pre row nextRow nextNextRow post me j
  | j >= length row = []
  | length row == length nextNextRow =
    gen_state_upper_piece_move_left_b0e7 j pre row nextRow (nextNextRow:post) me ++
    gen_state_upper_piece_move_right_b0e7 j pre row nextRow (nextNextRow:post) me ++
    gen_state_mid_piece_jump_left_b0e7 j pre row nextRow nextNextRow post me ++
    gen_state_mid_piece_jump_right_b0e7 j pre row nextRow nextNextRow post me ++
    gen_state_row_move_b0e7_jump_b0e7 pre row nextRow nextNextRow post me (j+1)
  | length row > length nextNextRow = 
    gen_state_upper_piece_move_left_b0e7 j pre row nextRow (nextNextRow:post) me ++
    gen_state_upper_piece_move_right_b0e7 j pre row nextRow (nextNextRow:post) me ++
    gen_state_upper_piece_jump_left_b0e7 j pre row nextRow nextNextRow post me ++
    gen_state_upper_piece_jump_right_b0e7 j pre row nextRow nextNextRow post me ++
    gen_state_row_move_b0e7_jump_b0e7 pre row nextRow nextNextRow post me (j+1)
  | otherwise =
    gen_state_lower_piece_move_left_b0e7 j pre row nextRow (nextNextRow:post) me ++
    gen_state_lower_piece_move_right_b0e7 j pre row nextRow (nextNextRow:post) me ++
    gen_state_lower_piece_jump_left_b0e7 j pre row nextRow nextNextRow post me ++
    gen_state_lower_piece_jump_right_b0e7 j pre row nextRow nextNextRow post me ++
    gen_state_row_move_b0e7_jump_b0e7 pre row nextRow nextNextRow post me (j+1)
  
-- For the side that starts on top
-- If (i < n-2), a chess piece on [i][j] can move to [i+1][j] or [i+1][j-1]
gen_state_upper_piece_move_left_b0e7 j pre row nextRow post me 
  | (j > 0) && (row !! j == me) && (nextRow !! (j-1) == '-') = 
    [pre++[(replace_b0e7 row j '-'), (replace_b0e7 nextRow (j-1) me)]++post]
  | otherwise = []
gen_state_upper_piece_move_right_b0e7 j pre row nextRow post me 
  | (j < length nextRow) && (row !! j == me) && (nextRow !! j == '-') = 
    [pre++[(replace_b0e7 row j '-'), (replace_b0e7 nextRow j me)]++post]
  | otherwise = []

-- If (i >= n-2), a chess piece on [i][j] can move to [i+1][j] or [i+1][j+1]
gen_state_lower_piece_move_left_b0e7 j pre row nextRow post me 
  | (row !! j == me) && (nextRow !! j == '-') = 
    [pre++[(replace_b0e7 row j '-'), (replace_b0e7 nextRow j me)]++post]
  | otherwise = []
gen_state_lower_piece_move_right_b0e7 j pre row nextRow post me 
  | (row !! j == me) && (nextRow !! (j+1) == '-') = 
    [pre++[(replace_b0e7 row j '-'), (replace_b0e7 nextRow (j+1) me)]++post]
  | otherwise = []

-- If (i < n-3), a chess piece on [i][j] can jump to [i+2][j] and capture an opponent_b0e7 piece on [i+1][j], or jump to [i+2][j-2] and capture a piece on [i+1][j-1]
gen_state_upper_piece_jump_left_b0e7 j pre row nextRow nextNextRow post me
  | (j > 1) && (row !! j == me) && (nextRow !! (j-1) == (opponent_b0e7 me)) && 
      (nextNextRow !! (j-2) == '-')=
    [pre++[replace_b0e7 row j '-', replace_b0e7 nextRow (j-1) '-', replace_b0e7 nextNextRow (j-2) me]++post]
  | otherwise = []
gen_state_upper_piece_jump_right_b0e7 j pre row nextRow nextNextRow post me
  | (j < length(nextNextRow)) && (row !! j == me) && 
      (nextRow !! j == (opponent_b0e7 me)) && (nextNextRow !! j  == '-') =
    [pre++[replace_b0e7 row j '-', replace_b0e7 nextRow j '-', replace_b0e7 nextNextRow j me]++post]
  | otherwise = []

-- If (i == n-3), a chess piece on [i][j] can jump to [i+2][j+1] and capture a piece on [i+1][j], or jump to [i+2][j-1] and capture [i+2][j-1]
gen_state_mid_piece_jump_left_b0e7 j pre row nextRow nextNextRow post me
  | (j > 0) && (row !! j == me) && (nextRow !! (j-1) == (opponent_b0e7 me)) && 
      (nextNextRow !! (j-1) == '-') =
    [pre++[replace_b0e7 row j '-', replace_b0e7 nextRow (j-1) '-', replace_b0e7 nextNextRow (j-1) me]++post]
  | otherwise = []
gen_state_mid_piece_jump_right_b0e7 j pre row nextRow nextNextRow post me
  | (j < length(nextRow)) && (row !! j == me) && 
      (nextRow !! j == (opponent_b0e7 me)) && (nextNextRow !! (j+1)  == '-') =
    [pre++[replace_b0e7 row j '-', replace_b0e7 nextRow j '-', replace_b0e7 nextNextRow (j+1) me]++post]
  | otherwise = []

-- If (i > n-3), a piece on [i][j] can jump to [i+2][j] and capture [i+1][j], or jump to [i+2][j+2] and capture [i+1][j+1]
gen_state_lower_piece_jump_left_b0e7 j pre row nextRow nextNextRow post me
  | (row !! j == me) && (nextRow !! j == (opponent_b0e7 me)) && 
      (nextNextRow !! j == '-')=
    [pre++[replace_b0e7 row j '-', replace_b0e7 nextRow j '-', replace_b0e7 nextNextRow j me]++post]
  | otherwise = []
gen_state_lower_piece_jump_right_b0e7 j pre row nextRow nextNextRow post me
  | (row !! j == me) && (nextRow !! (j+1) == (opponent_b0e7 me)) && 
      (nextNextRow !! (j+2)  == '-') =
    [pre++[replace_b0e7 row j '-', replace_b0e7 nextRow (j+1) '-', replace_b0e7 nextNextRow (j+2) me]++post]
  | otherwise = []

-- Replace the the i-th element of list with new
replace_b0e7 list i new
  | null list = []
  | i == 0 = new:tail list
  | otherwise = head list:replace_b0e7 (tail list) (i-1) new

opponent_b0e7 me 
  | me == 'w' = 'b'
  | otherwise = 'w'
