-- Name: Edward Soo, Annie Li
-- Student Number: 71680094, 

-- Returns the best next move
-- board: current state of the game, represented by an array of rows
-- side: 'w' or 'b'
-- moves: the number of moves to search ahead
oska_b0e7 :: [String] -> Char -> Integer -> [String]
oska_b0e7 board side moves = []








-- Use this function to generate all possible moves of current state
-- result does not include the current state; can be empty
gen_state_b0e7 board side
  | side == 'w' = gen_state_all_row_b0e7 [] board 'w'
  | otherwise = map reverse (gen_state_all_row_b0e7 [] (reverse board) 'b')

-- returns all possible states generated by making all legal moves of the board
gen_state_all_row_b0e7 pre [] side = []
gen_state_all_row_b0e7 pre post side =
  gen_state_row_b0e7 pre row (tail post) side ++
  gen_state_all_row_b0e7 (reverse(row:reverse pre)) (tail post) side
  where row = head post

-- returns all possible states generated by making all legal moves of a row
gen_state_row_b0e7 pre row post side
  -- last row
  | null post  = []
  -- second last row
  | length post == 1 = 
    gen_state_row_move pre row (head post) (tail post) side 0
  -- has more at least 2 rows below
  | otherwise = 
    gen_state_row_move_jump pre row (head post) (head (tail post)) (tail (tail post)) side 0

-- returns all possible states generated by making all legal moves of a row when the row only has one other row below it
gen_state_row_move pre row nextRow post side j
  | j >= length row = []
  | length row > length nextRow =
    gen_state_upper_piece_move_left_b0e7 j pre row nextRow post side++
    gen_state_upper_piece_move_right_b0e7 j pre row nextRow post side++
    gen_state_row_move pre row nextRow post side (j+1)
  | otherwise =
    gen_state_lower_piece_move_left_b0e7 j pre row nextRow post side++
    gen_state_lower_piece_move_right_b0e7 j pre row nextRow post side++
    gen_state_row_move pre row nextRow post side (j+1)
  
-- returns all possible states generated by making all legal moves of a row when the row has at least two rows below it
gen_state_row_move_jump pre row nextRow nextNextRow post side j
  | j >= length row = []
  | length row == length nextNextRow =
    gen_state_upper_piece_move_left_b0e7 j pre row nextRow (nextNextRow:post) side ++
    gen_state_upper_piece_move_right_b0e7 j pre row nextRow (nextNextRow:post) side ++
    gen_state_mid_piece_jump_left_b0e7 j pre row nextRow nextNextRow post side ++
    gen_state_mid_piece_jump_right_b0e7 j pre row nextRow nextNextRow post side ++
    gen_state_row_move_jump pre row nextRow nextNextRow post side (j+1)
  | length row > length nextNextRow = 
    gen_state_upper_piece_move_left_b0e7 j pre row nextRow (nextNextRow:post) side ++
    gen_state_upper_piece_move_right_b0e7 j pre row nextRow (nextNextRow:post) side ++
    gen_state_upper_piece_jump_left_b0e7 j pre row nextRow nextNextRow post side ++
    gen_state_upper_piece_jump_right_b0e7 j pre row nextRow nextNextRow post side ++
    gen_state_row_move_jump pre row nextRow nextNextRow post side (j+1)
  | otherwise =
    gen_state_lower_piece_move_left_b0e7 j pre row nextRow (nextNextRow:post) side ++
    gen_state_lower_piece_move_right_b0e7 j pre row nextRow (nextNextRow:post) side ++
    gen_state_lower_piece_jump_left_b0e7 j pre row nextRow nextNextRow post side ++
    gen_state_lower_piece_jump_right_b0e7 j pre row nextRow nextNextRow post side ++
    gen_state_row_move_jump pre row nextRow nextNextRow post side (j+1)
  
-- For the side that starts on top
-- If (i < n-2), a chess piece on [i][j] can move to [i+1][j] or [i+1][j-1]
gen_state_upper_piece_move_left_b0e7 j pre row nextRow post side 
  | (j > 0) && (row !! j == side) && (nextRow !! (j-1) == '-') = 
    [pre++[(replace row j '-'), (replace nextRow (j-1) side)]++post]
  | otherwise = []
gen_state_upper_piece_move_right_b0e7 j pre row nextRow post side 
  | (j < length nextRow) && (row !! j == side) && (nextRow !! j == '-') = 
    [pre++[(replace row j '-'), (replace nextRow j side)]++post]
  | otherwise = []

-- If (i >= n-2), a chess piece on [i][j] can move to [i+1][j] or [i+1][j+1]
gen_state_lower_piece_move_left_b0e7 j pre row nextRow post side 
  | (row !! j == side) && (nextRow !! j == '-') = 
    [pre++[(replace row j '-'), (replace nextRow j side)]++post]
  | otherwise = []
gen_state_lower_piece_move_right_b0e7 j pre row nextRow post side 
  | (row !! j == side) && (nextRow !! (j+1) == '-') = 
    [pre++[(replace row j '-'), (replace nextRow (j+1) side)]++post]
  | otherwise = []

-- If (i < n-3), a chess piece on [i][j] can jump to [i+2][j] and capture an opponent piece on [i+1][j], or jump to [i+2][j-2] and capture a piece on [i+1][j-1]
gen_state_upper_piece_jump_left_b0e7 j pre row nextRow nextNextRow post side
  | (j > 1) && (row !! j == side) && (nextRow !! (j-1) == (opponent side)) && 
      (nextNextRow !! (j-2) == '-')=
    [pre++[replace row j '-', replace nextRow (j-1) '-', replace nextNextRow (j-2) side]++post]
  | otherwise = []
gen_state_upper_piece_jump_right_b0e7 j pre row nextRow nextNextRow post side
  | (j < length(nextNextRow)) && (row !! j == side) && 
      (nextRow !! j == (opponent side)) && (nextNextRow !! j  == '-') =
    [pre++[replace row j '-', replace nextRow j '-', replace nextNextRow j side]++post]
  | otherwise = []

-- If (i == n-3), a chess piece on [i][j] can jump to [i+2][j+1] and capture a piece on [i+1][j], or jump to [i+2][j-1] and capture [i+2][j-1]
gen_state_mid_piece_jump_left_b0e7 j pre row nextRow nextNextRow post side
  | (j > 0) && (row !! j == side) && (nextRow !! (j-1) == (opponent side)) && 
      (nextNextRow !! (j-1) == '-') =
    [pre++[replace row j '-', replace nextRow (j-1) '-', replace nextNextRow (j-1) side]++post]
  | otherwise = []
gen_state_mid_piece_jump_right_b0e7 j pre row nextRow nextNextRow post side
  | (j < length(nextRow)) && (row !! j == side) && 
      (nextRow !! j == (opponent side)) && (nextNextRow !! (j+1)  == '-') =
    [pre++[replace row j '-', replace nextRow j '-', replace nextNextRow (j+1) side]++post]
  | otherwise = []

-- If (i > n-3), a piece on [i][j] can jump to [i+2][j] and capture [i+1][j], or jump to [i+2][j+2] and capture [i+1][j+1]
gen_state_lower_piece_jump_left_b0e7 j pre row nextRow nextNextRow post side
  | (row !! j == side) && (nextRow !! j == (opponent side)) && 
      (nextNextRow !! j == '-')=
    [pre++[replace row j '-', replace nextRow j '-', replace nextNextRow j side]++post]
  | otherwise = []
gen_state_lower_piece_jump_right_b0e7 j pre row nextRow nextNextRow post side
  | (row !! j == side) && (nextRow !! (j+1) == (opponent side)) && 
      (nextNextRow !! (j+2)  == '-') =
    [pre++[replace row j '-', replace nextRow (j+1) '-', replace nextNextRow (j+2) side]++post]
  | otherwise = []

-- Replace the the i-th element of list with new
replace :: [Char] -> Int -> Char -> [Char]
replace list i new
  | null list = []
  | i == 0 = new:tail list
  | otherwise = head list:replace (tail list) (i-1) new

opponent side 
  | side == 'w' = 'b'
  | otherwise = 'w'
